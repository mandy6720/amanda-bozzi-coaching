{"version":3,"sources":["../../../src/internal-plugins/query-runner/page-query-runner.js"],"names":["_","require","Promise","store","emitter","queryRunner","queuedDirtyActions","active","exports","runQueries","state","getState","uniq","a","payload","id","dirtyIds","findDirtyIds","runQueriesForIds","cleanIds","findIdsWithoutDataDependencies","on","push","action","runQueuedActions","allTrackedIds","flatten","concat","values","componentDataDependencies","nodes","connections","difference","pages","map","p","path","layouts","l","ids","length","resolve","all","pagesAndLayouts","plObj","find","pl","components","component","actions","reduce","node","internal","type","compact"],"mappings":"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","file":"page-query-runner.js","sourcesContent":["/**\n * Jobs of this module\n * - Ensure on bootstrap that all invalid page queries are run and report\n *   when this is done\n * - Watch for when a page's query is invalidated and re-run it.\n */\n\nconst _ = require(`lodash`)\nconst Promise = require(`bluebird`)\n\nconst { store, emitter } = require(`../../redux`)\nconst queryRunner = require(`./query-runner`)\n\nlet queuedDirtyActions = []\nlet active = false\n\nexports.runQueries = async () => {\n  active = true\n  const state = store.getState()\n\n  // Run queued dirty nodes now that we're active.\n  queuedDirtyActions = _.uniq(queuedDirtyActions, a => a.payload.id)\n  const dirtyIds = findDirtyIds(queuedDirtyActions)\n  await runQueriesForIds(dirtyIds)\n\n  // Find ids without data dependencies and run them (just in case?)\n  const cleanIds = findIdsWithoutDataDependencies()\n  // Run these pages\n  await runQueriesForIds(cleanIds)\n  return\n}\n\nemitter.on(`CREATE_NODE`, action => {\n  queuedDirtyActions.push(action)\n})\n\nconst runQueuedActions = async () => {\n  if (active) {\n    queuedDirtyActions = _.uniq(queuedDirtyActions, a => a.payload.id)\n    await runQueriesForIds(findDirtyIds(queuedDirtyActions))\n    queuedDirtyActions = []\n  }\n}\n\n// Wait until all plugins have finished running (e.g. various\n// transformer plugins) before running queries so we don't\n// query things in a 1/2 finished state.\nemitter.on(`API_RUNNING_QUEUE_EMPTY`, runQueuedActions)\n\nconst findIdsWithoutDataDependencies = () => {\n  const state = store.getState()\n  const allTrackedIds = _.uniq(\n    _.flatten(\n      _.concat(\n        _.values(state.componentDataDependencies.nodes),\n        _.values(state.componentDataDependencies.connections)\n      )\n    )\n  )\n\n  // Get list of paths not already tracked and run the queries for these\n  // paths.\n  return _.difference(\n    [\n      ...state.pages.map(p => p.path),\n      ...state.layouts.map(l => `LAYOUT___${l.id}`),\n    ],\n    allTrackedIds\n  )\n}\n\nconst runQueriesForIds = ids => {\n  if (ids.length < 1) {\n    return Promise.resolve()\n  }\n  const state = store.getState()\n  return Promise.all(\n    ids.map(id => {\n      const pagesAndLayouts = [...state.pages, ...state.layouts]\n      const plObj = pagesAndLayouts.find(\n        pl => pl.path === id || `LAYOUT___${pl.id}` === id\n      )\n      if (plObj) {\n        return queryRunner(plObj, state.components[plObj.component])\n      }\n    })\n  )\n}\n\nconst findDirtyIds = actions => {\n  const state = store.getState()\n  return actions.reduce((dirtyIds, action) => {\n    const node = state.nodes[action.payload.id]\n    // Check if the node was deleted\n    if (!node) {\n      return\n    }\n\n    // find invalid pagesAndLayouts\n    dirtyIds = dirtyIds.concat(state.componentDataDependencies.nodes[node.id])\n\n    // Find invalid connections\n    dirtyIds = dirtyIds.concat(\n      state.componentDataDependencies.connections[node.internal.type]\n    )\n\n    return _.compact(dirtyIds)\n  }, [])\n}\n"]}