{"version":3,"sources":["../../src/schema/data-tree-utils.js"],"names":["_","require","flatten","typeOf","createKey","INVALID_VALUE","Symbol","isDefined","v","isSameType","a","b","areAllSameType","list","every","current","i","prev","undefined","isEmptyObjectOrArray","obj","isObject","isEmpty","value","key","extractFieldExamples","nodes","mergeWith","isArray","cloneDeep","next","po","pn","stack","isNumber","isInteger","array","concat","filter","length","includes","slice","merged","buildFieldEnumValues","enumValues","values","maxDepth","safe","delimiter","Object","keys","forEach","field","module","exports"],"mappings":"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","file":"data-tree-utils.js","sourcesContent":["// @flow\nconst _ = require(`lodash`)\nconst flatten = require(`flat`)\nconst typeOf = require(`type-of`)\n\nconst createKey = require(`./create-key`)\n\nconst INVALID_VALUE = Symbol(`INVALID_VALUE`)\nconst isDefined = v => v != null\n\nconst isSameType = (a, b) => a == null || b == null || typeOf(a) === typeOf(b)\nconst areAllSameType = list =>\n  list.every((current, i) => {\n    let prev = i ? list[i - 1] : undefined\n    return isSameType(prev, current)\n  })\n\nconst isEmptyObjectOrArray = (obj: any): boolean => {\n  if (obj === INVALID_VALUE) {\n    return true\n    // Simple \"is object empty\" check.\n  } else if (_.isObject(obj) && _.isEmpty(obj)) {\n    return true\n  } else if (_.isObject(obj)) {\n    return _.every(obj, (value, key) => {\n      if (!isDefined(value)) {\n        return true\n      } else if (_.isObject(value)) {\n        return isEmptyObjectOrArray(value)\n      } else {\n        return false\n      }\n    })\n  }\n  return false\n}\n\n/**\n * Takes an array of source nodes and returns a pristine\n * example that can be used to infer types.\n *\n * Arrays are flattened to either: `null` for empty or sparse arrays or a\n * an array of a sigle merged example. e.g:\n *\n *  - ['red'], ['blue', 'yellow'] -> ['red']\n *  - [{ color: 'red'}, { color: 'blue', ht: 5 }] -> [{ color: 'red', ht: 5 }]\n *\n * @param {*Nodes} args\n */\nconst extractFieldExamples = (nodes: any[]) =>\n  // $FlowFixMe\n  _.mergeWith(\n    _.isArray(nodes[0]) ? [] : {},\n    ..._.cloneDeep(nodes),\n    (obj, next, key, po, pn, stack) => {\n      if (obj === INVALID_VALUE) return obj\n\n      // TODO: if you want to support infering Union types this should be handled\n      // differently. Maybe merge all like types into examples for each type?\n      // e.g. union: [1, { foo: true }, ['brown']] -> Union Int|Object|List\n      if (!isSameType(obj, next)) return INVALID_VALUE\n\n      if (!_.isArray(obj || next)) {\n        // Prefer floats over ints as they're more specific.\n        if (obj && _.isNumber(obj) && !_.isInteger(obj)) return obj\n        if (obj === null) return next\n        if (next === null) return obj\n        return undefined\n      }\n\n      let array = [].concat(obj, next).filter(isDefined)\n\n      if (!array.length) return null\n      if (!areAllSameType(array)) return INVALID_VALUE\n\n      // Linked node arrays don't get reduced further as we\n      // want to preserve all the linked node types.\n      if (_.includes(key, `___NODE`)) {\n        return array\n      }\n\n      // primitive values don't get merged further, just take the first item\n      if (!_.isObject(array[0])) return array.slice(0, 1)\n      let merged = extractFieldExamples(array)\n      return isDefined(merged) ? [merged] : null\n    }\n  )\n\nconst buildFieldEnumValues = (nodes: any[]) => {\n  const enumValues = {}\n  const values = flatten(extractFieldExamples(nodes), {\n    maxDepth: 3,\n    safe: true, // don't flatten arrays.\n    delimiter: `___`,\n  })\n  Object.keys(values).forEach(field => {\n    if (values[field] == null) return\n    enumValues[createKey(field)] = { field }\n  })\n\n  return enumValues\n}\n\nmodule.exports = {\n  INVALID_VALUE,\n  extractFieldExamples,\n  buildFieldEnumValues,\n  isEmptyObjectOrArray,\n}\n"]}